% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/MSnExperiment-class.R
\docType{methods}
\name{MSnExperiment}
\alias{MSnExperiment}
\alias{MSnExperiment-class}
\alias{readMSnExperiment}
\alias{setBackend}
\alias{applyProcessingQueue}
\alias{spectrapply,MSnExperiment-method}
\alias{acquisitionNum,MSnExperiment-method}
\alias{bpi,MSnExperiment-method}
\alias{centroided,MSnExperiment-method}
\alias{centroided<-,MSnExperiment,ANY-method}
\alias{collisionEnergy,MSnExperiment-method}
\alias{collisionEnergy<-,MSnExperiment-method}
\alias{featureData,MSnExperiment-method}
\alias{featureData<-,MSnExperiment,ANY-method}
\alias{featureNames,MSnExperiment-method}
\alias{fileNames,MSnExperiment-method}
\alias{fromFile,MSnExperiment-method}
\alias{intensity,MSnExperiment-method}
\alias{ionCount,MSnExperiment-method}
\alias{isCentroided,MSnExperiment-method}
\alias{isEmpty,MSnExperiment-method}
\alias{length,MSnExperiment-method}
\alias{metadata,MSnExperiment-method}
\alias{msLevel,MSnExperiment-method}
\alias{mz,MSnExperiment-method}
\alias{peaksCount,MSnExperiment,ANY-method}
\alias{polarity,MSnExperiment-method}
\alias{polarity<-,MSnExperiment-method}
\alias{precursorCharge,MSnExperiment-method}
\alias{precursorIntensity,MSnExperiment-method}
\alias{precursorMz,MSnExperiment-method}
\alias{precScanNum,MSnExperiment-method}
\alias{rtime,MSnExperiment-method}
\alias{rtime<-,MSnExperiment-method}
\alias{sampleData,MSnExperiment-method}
\alias{sampleData<-,MSnExperiment-method}
\alias{scanIndex,MSnExperiment-method}
\alias{smoothed,MSnExperiment-method}
\alias{smoothed<-,MSnExperiment,ANY-method}
\alias{spectraData,MSnExperiment-method}
\alias{spectraData<-,MSnExperiment-method}
\alias{spectraNames}
\alias{tic,MSnExperiment-method}
\alias{[,MSnExperiment,ANY,ANY,ANY-method}
\alias{[[,MSnExperiment,ANY,ANY-method}
\alias{filterAcquisitionNum,MSnExperiment-method}
\alias{filterEmptySpectra,MSnExperiment-method}
\alias{filterFile,MSnExperiment-method}
\alias{filterMsLevel,MSnExperiment-method}
\alias{filterMz,MSnExperiment-method}
\alias{clean,MSnExperiment-method}
\alias{removePeaks,MSnExperiment-method}
\title{The MSnExperiment class to manage and access MS data}
\usage{
MSnExperiment(x, spectraData, sampleData, metadata, ...)

readMSnExperiment(file, sampleData, backend = BackendMzR(),
  smoothed = NA, metadata = list(), ..., BPPARAM = bpparam())

setBackend(object, backend, ..., BPPARAM = bpparam())

applyProcessingQueue(x, BPPARAM = bpparam())

\S4method{spectrapply}{MSnExperiment}(object, FUN = NULL, ...,
  f = spectraData(object)$fileIdx, BPPARAM = bpparam())

\S4method{acquisitionNum}{MSnExperiment}(object)

\S4method{bpi}{MSnExperiment}(object, initial = TRUE,
  BPPARAM = bpparam())

\S4method{centroided}{MSnExperiment}(object, na.fail = FALSE)

\S4method{centroided}{MSnExperiment,ANY}(object) <- value

\S4method{collisionEnergy}{MSnExperiment}(object)

\S4method{collisionEnergy}{MSnExperiment}(object) <- value

\S4method{featureData}{MSnExperiment}(object)

\S4method{featureData}{MSnExperiment,ANY}(object) <- value

\S4method{featureNames}{MSnExperiment}(object)

\S4method{fileNames}{MSnExperiment}(object)

\S4method{fromFile}{MSnExperiment}(object)

\S4method{intensity}{MSnExperiment}(object)

\S4method{ionCount}{MSnExperiment}(object)

\S4method{isCentroided}{MSnExperiment}(object, ...,
  verbose = isMSnbaseVerbose())

\S4method{isEmpty}{MSnExperiment}(x)

\S4method{length}{MSnExperiment}(x)

\S4method{metadata}{MSnExperiment}(x, ...)

\S4method{msLevel}{MSnExperiment}(object)

\S4method{mz}{MSnExperiment}(object)

\S4method{peaksCount}{MSnExperiment,ANY}(object, BPPARAM = bpparam())

\S4method{polarity}{MSnExperiment}(object)

\S4method{polarity}{MSnExperiment}(object) <- value

\S4method{precursorCharge}{MSnExperiment}(object)

\S4method{precursorIntensity}{MSnExperiment}(object)

\S4method{precursorMz}{MSnExperiment}(object)

\S4method{precScanNum}{MSnExperiment}(object)

\S4method{rtime}{MSnExperiment}(object)

\S4method{rtime}{MSnExperiment}(object) <- value

\S4method{sampleData}{MSnExperiment}(object)

\S4method{sampleData}{MSnExperiment}(object) <- value

\S4method{scanIndex}{MSnExperiment}(object)

\S4method{smoothed}{MSnExperiment}(object)

\S4method{smoothed}{MSnExperiment,ANY}(object) <- value

\S4method{spectraData}{MSnExperiment}(object)

\S4method{spectraData}{MSnExperiment}(object) <- value

spectraNames(object)

\S4method{tic}{MSnExperiment}(object, initial = TRUE,
  BPPARAM = bpparam())

\S4method{[}{MSnExperiment,ANY,ANY,ANY}(x, i, j, ..., drop = TRUE)

\S4method{[[}{MSnExperiment,ANY,ANY}(x, i, j = "missing",
  drop = "missing")

\S4method{filterAcquisitionNum}{MSnExperiment}(object, n, file)

\S4method{filterEmptySpectra}{MSnExperiment}(object)

\S4method{filterFile}{MSnExperiment}(object, file)

\S4method{filterMsLevel}{MSnExperiment}(object, msLevel.)

\S4method{filterMz}{MSnExperiment}(object, mz, msLevel., ...)

\S4method{clean}{MSnExperiment}(object, all = FALSE,
  verbose = isMSnbaseVerbose(), msLevel.)

\S4method{removePeaks}{MSnExperiment}(object, t = "min",
  verbose = isMSnbaseVerbose(), msLevel.)
}
\arguments{
\item{x}{a \code{MSnExperiment} object.}

\item{spectraData}{for \code{MSnExperiment}: a \link[S4Vectors:DataFrame-class]{S4Vectors::DataFrame} object
with optional additional metadata columns for each spectrum.}

\item{sampleData}{a \link[S4Vectors:DataFrame-class]{S4Vectors::DataFrame} object with additional
information on each sample (samples as rows, information as columns).}

\item{metadata}{for \code{MSnExperiment} and \code{readMSnExperiment}: \code{list} with
optional metadata information.}

\item{...}{for \code{readMSnExperiment}: additional parameters to be passed to
the init method of the backend, such as \code{path} for \code{\link[=BackendHdf5]{BackendHdf5()}} to
define the directory where the hdf5 files should be saved.
For \code{spectrapply}: additional arguments to be passed to \code{FUN}.}

\item{file}{for \code{readMSnExperiment: }character\code{with the file names of the experiment. For}filterFile`: index or name of the file to which the
data should be subsetted.}

\item{backend}{a \linkS4class{Backend} derivate used for internal data storage.}

\item{smoothed}{\code{logical}, are the spectra smoothed?}

\item{BPPARAM}{should parallel processing be used? See
\code{\link[BiocParallel:bpparam]{BiocParallel::bpparam()}}.}

\item{object}{a \code{MSnExperiment} object.}

\item{FUN}{for \code{spectrapply}: a function or the name of a function to apply
to each \linkS4class{Spectrum} of the experiment.}

\item{f}{for \code{spectrapply}: \code{factor}, \code{character}, \code{numeric} or \code{logical}
(same length than there are spectra in \code{object}, i.e. with length
equal to \code{nrow(spectraData(object))} to define how the data should be
split into chunks for parallelization.}

\item{initial}{for \code{bpi} and \code{tic}: \code{logical(1)} whether the values in the
original input file should be returned (default) or whether the TIC and
BPI should be calculated on the actual data.}

\item{na.fail}{for \code{centroided}: whether a value of \code{NA} is not supported
as a result. Defaults to \code{FALSE}.}

\item{value}{for \code{featureData}, \code{sampleData} and \code{spectraData}: a \code{DataFrame}}

\item{verbose}{\code{logical(1)} defining the verbosity.}

\item{i}{for \code{[}: \code{integer}, \code{logical} or \code{character} specifying the
\strong{spectra} to which \code{object} should be subsetted.}

\item{j}{for \code{[}: not supported.}

\item{drop}{for \code{[}: if \code{drop = TRUE} and the object is subsetted to a single
element, a \code{Spectrum} class is returned; \code{drop = FALSE} returns always
a \code{MSnExperiment} object.}

\item{n}{For \code{filterAcquisitionNum}: \code{integer} with the acquisition numbers
to filter for.}

\item{msLevel.}{\code{integer} defining the MS level of the spectra to which the
function should be applied. For \code{filterMsLevel}: the MS level to which
\code{object} should be subsetted.}

\item{mz}{for \code{filterMz}: \code{numeric(2)} defining the lower and upper m/z to
trim/filter spectra.}

\item{all}{for \code{clean}: \code{logical(1)} whether all 0 intensity peaks should be
removed (\code{TRUE}) or whether 0-intensity peaks directly adjacent to a
non-zero intensity peak should be kept (\code{FALSE}).}

\item{t}{for \code{removePeaks}: a \code{numeric(1)} defining the threshold or \code{"min"}.}
}
\value{
See individual method description for the return value.
}
\description{
The \code{MSnExperiment} class encapsules data and meta-data for mass
spectrometry experiments.

It supersedes \linkS4class{MSnExp} and \linkS4class{OnDiskMSnExp} objects and supports
multiple data backends, e.g. in-memory (\linkS4class{BackendMemory}), on-disk as
mzML (\linkS4class{BackendMzR}) or HDF5 (\linkS4class{BackendHdf5}).
}
\details{
The \code{MSnExperiment} class uses by default a lazy data manipulation strategy,
i.e. data manipulations such as performed with \code{removePeaks} are not applied
immediately to the data, but applied on-the-fly to the spectrum data once it
is retrieved.
}
\section{Creation of objects, conversion and changing the backend}{


\code{MSnExperiment} classes are usually created with the \code{readMSnExperiment}
function that reads general spectrum metadata information from the  mass
spectrometry data files.

Alternatively it is possible to create a new object from a list of \code{Spectrum}
objects using the \code{MSnExperiment} function. Additional spectrum metadata
columns can be provided with the \code{spectraData} argument, sample annotations
with the \code{sampleData} argument and arbitrary metadata with the \code{metadata}
argument. Note that objects created with the \code{MSnExperiment} constructor
function can not use the \code{BackendMzR} as backend.

\code{MSnExperiment} objects can be converted to a \code{list} or
\link[S4Vectors:List-class]{S4Vectors::List} of \code{Spectrum} objects with the \code{as(object, "list")}
and \code{as(object, "List")} function, respectively.

The \linkS4class{Backend} can be changed with the \code{setBackend} function by
specifying the new \linkS4class{Backend} with the \code{backend} parameter. See examples
for more details.
}

\section{Accessing data}{

\itemize{
\item \code{acquisitionNum}: get the acquisition number of each spectrum as a
named \code{integer} vector with the same length than \code{object}.
\item \code{bpi}: get the base peak intensity (largest signal of a spectrum) for all
spectra in \code{object}. By default (\code{initial = TRUE}) the base peak intensity
reported in the original raw data file is returned. Use \code{initial = FALSE}
to calculate on the actual spectra data. Returns a \code{numeric} vector with
length equal to the number of spectra.
\item \code{centroided}, \code{centroided<-}: get or set the centroiding information of
the spectra. \code{centroided} eturns a \code{logical} vector (same length than
\code{object} with names being the spectrum names) with \code{TRUE} if a spectrum
is centroided, \code{FALSE} if it is in profile more and \code{NA} if it is
undefined. This function returns the value defined in the spectrum
metadata. See also \code{isCentroided} for estimating from the spectrum data
whether the spectrum is centroided. \code{centroided<-} either takes a single
\code{logical} or \code{logical} with the same length than spectra.
\item \code{collisionEnergy}, \code{collisionEnergy<-}: get or set the collision energy
for all spectra in \code{object}.
\item \code{featureData}: get or set general spectrum metadata. Returns a \code{DataFrame}
or a \code{MSnExperiment} with updated spectra metadata. Each row of the
\code{DataFrame} contains information for one spectrum. This function is
equivalent to \code{\link[=featureData]{featureData()}} of \code{MSnExp}/\code{OnDiskMSnExp} objects.
\item \code{featureNames}: extract the feature (spectrum) names.
\item \code{fileNames}: get the original file names from which the data was imported.
\item \code{fromFile}: get the file/sample assignment of each spectrum. Returns a
named integer vector of length equal to the number of spectra and names
being the spectrum names.
\item \code{intensity}: get the intensity values from the spectra. Returns a named
list, names being the spectrum names, each element a numeric vector with
the intensity values of one spectrum.
\item \code{ionCount}: returns a \code{numeric} (names being spectrum names, length equal
to the number of spectra) representing the sum of intensities for each
spectrum. In contrast to \code{tic}, this function calculates the actual ion
count on the data.
\item \code{isCentroided}: a heuristic approach  assessing if the spectra in \code{object}
are in profile or centroided mode. The function takes the \code{qtl}th quantile
top peaks, then calculates the difference between adjacent M/Z value and
returns \code{TRUE} if the first quartile is greater than \code{k}. (See
\code{MSnbase:::.isCentroided} for the code.)
\item \code{isEmpty}: whether a spectrum in \code{object} is empty (i.e. does not contain
any peaks). Returns a logical vector (length equal number of spectra, names
being the spectrum names).
\item \code{length}: get the number of spectra in the object.
\item \code{metadata}: get the metadata \code{list}.
\item \code{msLevel}: get the spectra's MS level. Returns an integer vector (names
being spectrum names, length equal to the number of spectra) with the MS
level for each spectrum.
\item \code{mz}: get the mass-to-charge ratios (m/z) from the spectra. Returns a named
list, names being the spectrum names, each element a numeric vector with
the m/z values of one spectrum.
\item \code{polarity}, \code{polarity<-}: get or set the polarity for each spectrum.
\code{polarity} returns an integer vector (names being spectrum names, length
equal to the number of spectra), with \code{0} and \code{1} representing negative
and positive polarity, respectively. \code{polarity<-} expects an integer vector
of length 1 or equal to the number of spectra.
\item \code{peaksCount}: get the number of peaks (m/z-intensity values) per spectrum.
Returns an integer vector (names being spectrum names, length equal to the
number of spectra).
\item \code{precursorCharge}, \code{precursorIntensity}, \code{precursorMz}, \code{precScanNum}: get
the charge, intensity, m/z and scan index of the precursor for MS level > 2
from the object. Returns a named vector of length equal to the number of
spectra in \code{object}.
\item \code{rtime}, \code{rtime<-}: get or set the retention times for each spectrum.
\code{rtime} returns a \code{numeric} vector (names being spectrum names, length
equal to the number of spectra) with the retention time for each spectrum.
\code{rtime<-} expects a numeric vector with length equal to the number of
spectra.
\item \code{sampleData}: get or set sample metadata. Returns a \code{DataFrame}, each row
containing information for one sample or file or a \code{MSnExperiment} with
the update sample metadata. This function is equivalent to \code{\link[=phenoData]{phenoData()}}
of \code{MSnExp}/\code{OnDiskMSnExp} objects.
\item \code{scanIndex}: get the \emph{scan index} for each spectrum. This represents the
relative index of the spectrum within each file (i.e. for each sample).
Note that this can be different to the \code{acquisitionNum} of the spectrum
which is the index of the spectrum as reported in the mzML file.
\item \code{smoothed},\code{smoothed<-}: get or set the information whether a spectrum
was \emph{smoothed} (see \code{\link[=smooth]{smooth()}}). \code{smoothed} returns a logical vector of
length equal to the number of spectra. \code{smoothed<-} takes a logical
vector of length 1 or equal to the number of spectra in \code{object}.
\item \code{spectraData}: get or set general spectrum metadata. See \code{featureData}
above.
\item \code{spectraNames}: same as \code{featureNames}: returns the names of the spectra.
\item \code{spectrapply}: apply an arbitrary function to each spectrum in the dataset
and return its result. The function returns a \code{list} with the same length
than there are spectra. Argument \code{f} allows to define how to split the
data/spectra into chunks for paralellization. By default data access and
application of the provided function are parallelized by file.
\item \code{tic}: get the total ion current/count (sum of signal of a spectrum) for
all spectra in \code{object}. By default (\code{initial = TRUE}) the value
reported in the original raw data file is returned. Use \code{initial = FALSE}
to calculate on the actual spectra data. Returns a \code{numeric} vector with
length equal to the number of spectra.
}
}

\section{Subsetting and filtering}{

\itemize{
\item \code{[i]}: subset the object by spectra (\code{i}). Returns an \code{MSnExperiment},
unless \code{drop = TRUE} and the object is subsetted to a single spectrum,
in which case a \code{Spectrum} is returned.
\item \code{[[i]]}: extract the \linkS4class{Spectrum} with index \code{i} from the data.
\item \code{filterAcquisitionNum}: filter the object keeping only spectra matchin the
provided acquisition numbers (argument \code{n}). If \code{file} is also provided,
\code{object} is subsetted to the spectra with an acquisition number equal to
\code{n} \strong{in this/these file(s)} and all spectra for the remaining files (not
specified with \code{file}).
\item \code{filterEmptySpectra}: remove empty spectra from \code{object}.
\item \code{filterFile}: subset the object by file. Returns an \code{MSnExperiment}.
\item \code{filterMsLevel}: filter object by MS level keeping only spectra matching
the MS level specified with argument \code{msLevel.}. Returns the filtered
\code{MSnExperiment}.
\item \code{filterMz}: filter/trim all spectra in \code{object} to the provided m/z range.
Returns the filtered \code{MSnExperiment}.
}
}

\section{Data manipulation methods}{


Data manipulation operations, such as those listed in this section,  are by
default not applied immediately to the spectra, but added to a
\emph{lazy processinq queue}. Operations stored in this queue are applied
on-the-fly to spectra data each time it is accessed. This lazy
execution guarantees the same functionality for \code{MSnExperiment} objects with
any backend, i.e. backends supporting to save changes to spectrum data
(\code{\link[=BackendMemory]{BackendMemory()}} and \code{\link[=BackendHdf5]{BackendHdf5()}} as well as read-only backends (such
as the \code{\link[=BackendMzR]{BackendMzR()}}).
\itemize{
\item \code{applyProcessingQueue}: make data manipulations persistent, i.e. apply all
data manipulation operations stored in the processing queue to each
spectrum and store this data in the backend. This does not work for
read-only backends such as the \code{\link[=BackendMzR]{BackendMzR()}}. The function returns
the \code{MSnExperiment} with data manipulations applied and stored in the
backend.
\item \code{clean}: remove 0-intensity data points. See \code{\link[=clean]{clean()}} for
\linkS4class{Spectrum} objects for more details.
\item \code{removePeaks}: remove peaks lower than a threshold \code{t}. See
\code{\link[=removePeaks]{removePeaks()}} for \linkS4class{Spectrum} objects for more details.
}
}

\examples{

## Create an MSnExperiment from a list of Spectrum objects
spl <- list(new("Spectrum1", rt = 1.2, mz = 1:4, intensity = abs(rnorm(4))),
    new("Spectrum1", rt = 1.3, mz = 1:4, intensity = abs(rnorm(4))))
mse <- MSnExperiment(spl)
mse

## Access the second spectrum
mse[[2]]

## Get the spectrum metadata
spectraData(mse)

## Add an additional column to the spectrum metadata
spectraData(mse)$peak_id <- c("a", "b")

## featureData and spectraData both access the spectrum metadata
featureData(mse)

## Get the intensity values and the m/z values for each spectrum
intensity(mse)
mz(mse)

## The spectrapply function can be used to apply any function to a spectrum
## and get its result. Below we use spectrapply to get the m/z and intensity
## values per spectrum as a data.frame
spectrapply(mse, as.data.frame)

## filter all spectra by m/z keeping m/z - intensity pairs with an m/z
## between 2 and 3.
mse_filt <- filterMz(mse, mz = c(2, 3))
mz(mse_filt)
intensity(mse_filt)

## Create an MSnExperiment from two input files using the on-disk
## BackendMzR backend
sf <- dir(system.file("sciex", package = "msdata"), full.names = TRUE)
mse <- readMSnExperiment(sf, backend = BackendMzR())
mse

## Get associated file names
fileNames(mse)

## Get spectra metadata
spectraData(mse)

## Subset the object to contain only spectra 3, 12, 45
mse_sub <- mse[c(3, 12, 45)]
mse_sub

## Are the spectra centroided?
centroided(mse_sub)

## Get the total ion current reported in the original files
tic(mse_sub)

## Calculate the TIC from the actual data
tic(mse_sub, initial = FALSE)

## Coerce to a list of spectra
as(mse_sub, "list")

## Subset the object to contain only spectra from the second file
mse_sub <- filterFile(mse, 2)
fileNames(mse_sub)

## Apply an arbitrary function to each spectrum and return its results.
## We calculate the mean intensity for each spectrum. By
## default the function parallelizes the operation FUN by file.
res <- spectrapply(mse, FUN = function(z) mean(intensity(z)))
head(res)

## Parameter `f` can be used to specify how the function splits the data
## into chunks for parallel processing. Below we disable parallel processing
## by defining a single chunk.
res <- spectrapply(mse, f = rep(1, nrow(spectraData(mse))),
    FUN = function(z) mean(intensity(z)))
head(res)

## The `setBackend` function can be used to change the backend for the
## `MSnExperiment`. Below we change the backend from the default raw MS
## data files-based backend (`BackendMzR`) to the HDF5-file based
## `BackendHdf5`. With the additional `path` parameter we specify the
## directory in which the HDF5 files should be saved.
mse <- setBackend(mse, backend = BackendHdf5(),
    path = paste0(tempdir(), "/hdf5"))
mse
}
\author{
Sebastian Gibb, Johannes Rainer
}
